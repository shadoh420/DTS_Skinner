<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>DTS Model Skinner</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #101010; }
    #controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white; border-radius: 5px; z-index: 10;}
    #controls label, #controls input, #controls button, #controls select { margin: 5px; display: block; margin-bottom: 8px; }
    #controls input[type="text"], #controls select { width: 150px; padding: 3px; }
    #controls button { padding: 5px 10px; }
    .rotation-controls button { margin-right: 5px; }
    canvas { display: block; }
  </style>

  <script defer src="/static/three.min.js"></script>
  <script defer src="/static/OrbitControls.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
</head>
<body>
  <div id="controls">
    <div>
      <label for="modelSelect">Select Model:</label>
      <select id="modelSelect"></select>
    </div>
    <div>
      <label for="textureName">Texture File:</label>
      <input type="text" id="textureName" value="disc.png">
    </div>
    <button id="loadModelBtn">Load/Refresh Model</button>
    <hr>
    <div class="rotation-controls">
        <span>Rotate Model:</span><br>
        X: <button id="rotX90">+90</button> <button id="rotXN90">-90</button><br>
        Y: <button id="rotY90">+90</button> <button id="rotYN90">-90</button><br>
        Z: <button id="rotZ90">+90</button> <button id="rotZN90">-90</button><br>
        <button id="resetRot">Reset Rotation</button>
    </div>
    <div id="status" style="margin-top:10px;"></div>
  </div>
  <canvas id="c"></canvas>
  <script>
  window.addEventListener('DOMContentLoaded', async () => { // Made async for initial model list fetch
    const canvas = document.getElementById('c');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0.7, 2.5); // Adjusted default camera
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x101010);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.12;
    controls.target.set(0, 0.3, 0); // Adjusted default target

    const socket = io();
    const statusDiv = document.getElementById('status');
    const modelSelect = document.getElementById('modelSelect');
    const textureNameInput = document.getElementById('textureName');
    const loadModelBtn = document.getElementById('loadModelBtn');

    let currentModelGroup, currentMaterial, currentTextureName, currentModelName;
    const DEG_TO_RAD = Math.PI / 180;

    // --- Populate Model Dropdown ---
    try {
        const response = await fetch('/list_models');
        if (!response.ok) throw new Error('Failed to fetch model list');
        const models = await response.json();
        if (models.length === 0) {
            modelSelect.innerHTML = '<option value="">No models found in static/model_json/</option>';
            loadModelBtn.disabled = true;
        } else {
            models.forEach(m => {
                const option = document.createElement('option');
                option.value = m.model_name;
                option.textContent = m.model_name;
                option.dataset.texture = m.texture_name; // Store guessed texture
                modelSelect.appendChild(option);
            });
            // Auto-select first model and set its texture
            if (modelSelect.options.length > 0) {
                modelSelect.selectedIndex = 0;
                textureNameInput.value = modelSelect.options[modelSelect.selectedIndex].dataset.texture || '';
                currentModelName = modelSelect.value; // Set for initial load
                currentTextureName = textureNameInput.value;
                if (currentModelName && currentTextureName) {
                    loadModel(currentModelName, currentTextureName);
                }
            }
        }
    } catch (error) {
        console.error("Error fetching model list:", error);
        statusDiv.textContent = "Error loading model list.";
        modelSelect.innerHTML = '<option value="">Error loading models</option>';
        loadModelBtn.disabled = true;
    }

    modelSelect.addEventListener('change', () => {
        const selectedOption = modelSelect.options[modelSelect.selectedIndex];
        if (selectedOption && selectedOption.dataset.texture) {
            textureNameInput.value = selectedOption.dataset.texture;
        }
        // Automatically load on change, or require button press
        // For now, let's require button press to avoid too many loads
    });


    async function fetchTex(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Failed to fetch texture ${url}: ${r.statusText}`);
      const blob = await r.blob();
      return await createImageBitmap(blob);
    }

    async function loadModel(modelName, textureFilename) {
      statusDiv.textContent = `Loading ${modelName}...`;
      currentModelName = modelName; // Store for reload reference
      currentTextureName = textureFilename;

      try {
        if (currentModelGroup) { // Use a group to handle model and its rotations
          scene.remove(currentModelGroup);
          if(currentModelGroup.children.length > 0 && currentModelGroup.children[0].geometry) {
            currentModelGroup.children[0].geometry.dispose();
          }
          if (currentMaterial && currentMaterial.map) currentMaterial.map.dispose();
          if (currentMaterial) currentMaterial.dispose();
        }
        currentModelGroup = new THREE.Group(); // Create a group for easier rotation
        scene.add(currentModelGroup);

        const modelJsonUrl = `/model_json/${modelName}`;
        const modelResponse = await fetch(modelJsonUrl);
        if (!modelResponse.ok) {
            const errorText = await modelResponse.text();
            throw new Error(`Failed to load model JSON ${modelJsonUrl}: ${modelResponse.statusText}. Server: ${errorText}`);
        }
        const d = await modelResponse.json();

        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(d.v), 3));
        g.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(d.uv), 2));
        g.setIndex(d.tri);
        g.computeVertexNormals();
        g.computeBoundingSphere();
        
        if (g.boundingSphere) {
            console.log(`Model: ${modelName}, BoundingSphere Radius: ${g.boundingSphere.radius}`);
            const center = g.boundingSphere.center;
            const radius = g.boundingSphere.radius;
            
            // Offset the geometry so its center is at the group's origin
            g.translate(-center.x, -center.y, -center.z); 
            
            controls.target.set(0, 0, 0); // Target the group's origin
            const camDist = Math.max(radius * 2.0, 1.0); // Ensure a minimum distance
            camera.position.set(0, radius * 0.3 , camDist);
            camera.lookAt(0,0,0);
            controls.update(); // Important after manual camera changes
        }

        const textureUrl = `/texture/${textureFilename}`;
        const img = await fetchTex(`${textureUrl}?t=${Date.now()}`);
        const tex = new THREE.Texture(img);
        tex.needsUpdate = true;
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;

        currentMaterial = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(g, currentMaterial);
        currentModelGroup.add(mesh); // Add mesh to the group

        statusDiv.textContent = `${modelName} loaded with ${textureFilename}.`;

      } catch (error) {
        console.error("Error loading model:", error);
        statusDiv.textContent = `Error: ${error.message}`;
      }
    }

    loadModelBtn.addEventListener('click', () => {
      const modelName = modelSelect.value;
      const textureName = textureNameInput.value.trim();
      if (modelName && textureName) {
        loadModel(modelName, textureName);
      } else {
        statusDiv.textContent = "Please select a model and ensure texture filename is entered.";
      }
    });

    socket.on('texture_updated', async (data) => {
      if (!currentMaterial || !currentModelGroup || !data.filename) return;
      if (data.filename === currentTextureName) { // Check against stored currentTextureName
        statusDiv.textContent = `Reloading texture ${data.filename}...`;
        try {
          const img = await fetchTex(`/texture/${data.filename}?t=${Date.now()}`);
          currentMaterial.map.image = img;
          currentMaterial.map.needsUpdate = true;
          statusDiv.textContent = `Texture ${data.filename} reloaded.`;
        } catch (error) {
          console.error("Error reloading texture:", error);
          statusDiv.textContent = `Error reloading texture: ${error.message}`;
        }
      }
    });
    
    // --- Rotation Button Logic ---
    function rotateObject(axis, angleDeg) {
        if (!currentModelGroup) return;
        const angleRad = angleDeg * DEG_TO_RAD;
        const q = new THREE.Quaternion();
        if (axis === 'x') q.setFromAxisAngle(new THREE.Vector3(1,0,0), angleRad);
        if (axis === 'y') q.setFromAxisAngle(new THREE.Vector3(0,1,0), angleRad);
        if (axis === 'z') q.setFromAxisAngle(new THREE.Vector3(0,0,1), angleRad);
        currentModelGroup.quaternion.premultiply(q); // Apply rotation relative to current orientation
    }

    document.getElementById('rotX90').addEventListener('click', () => rotateObject('x', 90));
    document.getElementById('rotXN90').addEventListener('click', () => rotateObject('x', -90));
    document.getElementById('rotY90').addEventListener('click', () => rotateObject('y', 90));
    document.getElementById('rotYN90').addEventListener('click', () => rotateObject('y', -90));
    document.getElementById('rotZ90').addEventListener('click', () => rotateObject('z', 90));
    document.getElementById('rotZN90').addEventListener('click', () => rotateObject('z', -90));
    document.getElementById('resetRot').addEventListener('click', () => {
        if (currentModelGroup) currentModelGroup.rotation.set(0,0,0);
    });


    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

  });
  </script>
</body>
</html>